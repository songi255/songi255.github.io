---
layout: post
title: Desktop Visual Timer 작업일지 4 - [총평]
description:
img_path: "/assets/img/timetimer"
image:
  path: timetimer_unsplash.jpg
  alt: Time Timer - Unsplash의 Ralph Hutter
pin: false
categories: [Project, Desktop Visual Timer]
tags:
date: 2023-09-12 22:52 +0900
---

기초설계 이야기 하다가 갑자기 총평으로 넘어왔는데, 조금 현타가 와버렸다. ㅋㅋ

블로그를 처음하다보니까 이런저런 글들을 작성해보고 싶었는데, 작업일지도 그 중 하나였다. 경험이 많은것은 아니지만 누군가에게는 도움이 되겠지라는 생각으로...

그런데 글을 작성하면 할수록 고수에게는 어설프고 초보에게는 어려운 느낌이 짙어지는 느낌이었다. 구현내용이 정형화된 패턴내용도 아니고 이런 글을 대체 누가읽을까 싶었다.
그래서 이쯤에서 마무리하고 좋은 교훈으로 삼으려고 한다.

## 1. JavaFX 평가

### 1-1. 크로스 플랫폼

크로스 플랫폼은 Java의 장점이었는데, 요즘에는 대체제가 많아서 확실히 덜 부각되는 느낌이다. 또한 실행컴퓨터에 JRE를 설치해야 하는 것 또한 나름의 유입방해물로 작용하는 느낌이었다.

### 1-2. 리소스 사용량

JavaFX는 최적화하지 않으면 `Hello World!` 띄우는데에 `200MB` 정도까지도 메모리를 잡아먹는다. 이는 성능관점에서 Heap을 미리 할당해두기 때문이다. 요즘 컴퓨터 사양들을 보면 크게 부담될 용량은 아니지만 가벼운 프로그램을 만들고 싶은 입장에서는 좀 그렇긴 하다. 따라서 VM Option을 통해 적절하게 옵티마이징할 필요가 있다. 이는 또 하나의 학습곡선이 된다.

### 1-3. 학습곡선

기본 Java 개발자들의 학습곡선을 많이 줄였다고 말하지만, 실제 경험상으로는 그렇지 않는듯하다. 실제로 지금처럼 간단한 프로그램이라도 제대로 만들기 위해서는 JavaFX 아키텍처에 대한 이해가 동반되어야 한다. 어떤 특성들이 ReadOnly로 구성되어있는지, 어떤 작업들이 JavaFX Application Thread에서 실행되는지, FXMLLoader의 동작방식이라던지, 그리고 수많은 api들을 숙지해야 한다.

그리고 제일 중요한건 핵심구조인 MVVM을 제대로 계층을 나눠서 개발할 수 있어야 코드가 더러워지지 않는다. 하지만 깔끔하게 종속성을 관리하고 코드영역을 분리하는 것이 디자인패턴같은 선수지식이나 경험이 없으면 쉬운 일은 아니다. 특히나 MVVM은 오래되기도 했고, 사람마다 이해나 정의가 살짝씩 다른 불명확한 패턴이기 떄문에...

### 1-4. 관리부실

관리가 잘 안된다. 예를 들어 Windows에 우측하단에 알림을 띄우는 기능은 JavaFX에서는 따로 지원되지 않아 AWT 라이브러리를 사용해야 한다. 이때 AWT는 VM에 의해 관리되는 자체 Thread를 또 따로 돌리게된다...

그리고 Windows에서는 full screen을 하면 always on top 설정이 무효화되서, always on top 을 false로 했다가 다시 true로 설정해야하는 버그 등... 일반적인 디버깅으로 해결하기 힘든 경우가 생긴다.

### 1-5. FXML과 CSS의 미흡

HTML 처럼 div와 css로 레이아웃을 자유롭게 구성할 수 있다고 생각하면 큰코다친다.

- `width: 50%`는 사용할 수 없다. JavaFX 렌더링 아키텍처에 의해 `%`는 지원되지 않는다.
- `width: 50px`는 어떤 컴포넌트는 사용할 수 없다. resizable하지 않기 때문이다.

반응형 디자인을 하기 위해서는 직접 Pane 클래스를 확장해야 한다. 만약 이 사실을 알아내지 못하고 property와 애니메이션을 통해 반응형 레이아웃을 구현했다면... 슬프지만 큰 성능저하(flicker)가 동반된다.

개인적으로는 이럴거면 차라리 `.css` 확장자를 `.fxss` 같은 걸로 설정해서 오해를 방지했으면 싶다. 애초에 CSS Parser도 전용파서를 사용한다...

그리고 결국 View가 변경되면 ViewModel도 높은 확률로 변경된다. 바인딩 문제가 있기 때문이다. 이 때 굳이 resource 폴더에 분리해둔 FXML을 찾아가는것이 오히려 더 번거롭다. 그리고 위에서 봤듯 CSS로 해결할 수 없는 부분은 직접 코드작성을 해야하고, `Transition` 도 CSS에서는 지원되지 않아 직접 Java 코드로 작성해야 한다. 혼용은 안하느니만 못하다. 결론은 애초에 코드로 작성하는 편이 속편하다. 물론 이 경우 Scene builder는 쓸 수 없다.

### 1-6. JavaFX 총평

총평은 `☆★★★★`정도로 주겠다. 애초에 Java에 대한 애정이 없었다면 더 낮았을 것이다. 미운놈 떡하나 더 주는 상황이 반복해서 발생했다. 문제가 생기고 JavaFX에 실망했다가도, 해결방법을 알고나면 조금 더 애정이 생기고하는 그런 웃긴 상황이 반복되었다. 애증... 애증이 정확한 표현인 것 같다.

물론 다른사람이 시도한다면 일단은 말리겠다.

## 2. 교훈

### 2-1. 과도한 엔지니어링

지금 생각해보면, 굳이 프레임워크가 아니더라도 팩토리를 정의해서 간단한 DI를 구현할 수 있었다고 생각한다. AOP 또한 필드를 javafx.Property 로 변경하고 Listener를 달아줌으로써 구현할 수 있는 내용들이었다. 물론 DI, AOP 도입에 많은 시간이 소요된 것은 아니지만, 그래도 너무 돌아간것이 아닌가 하는 반성을 하게되었다.

### 2-2. State 남용

설계 처음부터 TimerState 라는 Enum을 도입했는데, 나중에 보니 기존 정보들로 도출될 수 있는 상태들이었고, 제일 중요한 포인트는 Worker thread에서 접근하고 있는지 여부였다. 상태관리 개념을 도입하면 복잡도가 증가하기 때문에, 꼭 필요한 곳에만 사용하는 습관을 들일 생각이다.

### 2-3. 프로토타입의 중요성

확실히 실제로 프로토타입을 제작하고 시험삼아 사용해보니, 어떤 기능이 추가로 필요한지, 어떤 UI/UX가 불편했는지 등이 확 와닿았다. "사람들은 자신이 뭘 원하는지 모른다"라는 스티브잡스의 말처럼, 실제 대부분의 고객들도 그런 상태라고 생각한다.

그리고 프로그램 설계와 관련된 통찰들도 많이 얻을 수 있었다. 이게 더 좋을까 저게 더 좋을까 노트에 하루종일 설계하는 것 보다 직접 코드로 한번 구현해 보는 편이 훨씬 빠르다는 것이 각인되었다.

**기획과 설계에 매몰되는것 보다 한번 시험삼아 해보는것이 훨씬 더 큰 통찰을 안겨준다.** 만약 서비스업체에서 일하게 된다면 무조건 프로토타입 방식으로 일할 것 같다.

### 2-4. TDD

타이머를 만드는 동안 켄트백의 TDD 책을 같이 읽었는데, 다 읽고 나니 충격이 컸다. 자신감, 책임감, 그리고 답없는 고민에 소요되는 시간들... 평소 제일 많이 고민하던 부분들에 대한 해결책을 그대로 제시해주는 느낌이었다. 완벽주의에 매몰된 사람이라면 그 어떤 개발도서보다 필독서가 아닐까 조심스럽게 생각한다. 다음 프로젝트부터는 무조건 도입하고 연습해 볼 생각이다.

### 2-5. CI/CD

어느 시점에서 JavaFX에 대한 애정이 팍 식어서, 그냥 빨리 마무리해버리고 싶어졌다. 대충 코드를 정리하고 메이븐 빌드를 돌렸는데 빌드가 되질 않았다... 아니, IDE에서는 실행이 되는데 빌드는 안된다니? 원인은 java9+ 부터 도입된 모듈시스템 때문이었는데, Guice나 Reflection 관련 Dependency가 Automatic module이었기 떄문이다. 쉽게말하면 구식버전이라서 패키지 과정(JLink)에서 문제가 생긴다. 프로젝트의 핵심라이브러리때문에 빌드가 안된다니? 정말 가슴이 철렁했다.

JLink는 명시된 모듈구조를 사용해서 필요한 종속성만 포함시키는 도구인데, 보통 class 등의 이름을 통해 Reflection 하는 라이브러리들은 종속성이 동적으로 결정되기에 모듈시스템을 지원하지 않는 경우가 꽤 있는듯하다.

이런경우 기존의 fat jar로 모든 종속성을 구겨넣어 패키징을 할 수는 있다. 그리고 jar를 실행해보면 단 한줄의 오류메시지가 반겨준다.

> "javafx 런타임 구성요소가 누락되었습니다."

음. 어쩌라는거지? 검색을 해보면 vm 옵션에서 module path 설정을 해주라는 이야기를 힘겹게 볼 수 있는데, 그말은 최종사용자가 openjfx sdk 까지 설치하고 해당 설치경로를 제공해서 외부 jar를 통해 실행하라는 말이다. 현실적인 해결책은 아니다.

jar을 뜯어보고 다른 jar랑 합쳐도 보고, Maven Repository에서 모든 종속성 코드를 다운로드받아 대체하면서 모듈을 직접 명시해보기도 하고, 별의 별 짓을 다 해봤던 것 같다. 그리고 내린 결론은 모듈시스템과 class-path 인식 사이에 뭔가 문제가 있다는 것이었다.

그렇게 키워드를 수정해서 검색한 결과 open javafx 11버전 이상부터 도입된 LaunchHelper 클래스에서 명시적 모듈을 기준으로 로딩을 하기때문에 javafx 모듈에 대한 일반적인 classpath 사용이 제한된다는 내용을 힘겹게 찾을 수 있었다. 그래서 Launcher Class를 따로 만들어 javafx가 아닌 일반 프로그램을 실행하는것처럼 LaunchHelper를 속이는 방식으로 구동이 가능했다.

저런 형식의 에러메시지를 남기는 JavaFX도 큰 문제라고 생각하지만, 애초에 CI/CD 환경에서 작업을 했다면 이런 수모를 겪었을까? 아마 Guice 도입시점부터 문제를 확인하고 대안을 모색했을 것이다. 데스크탑 프로그램인데 굳이 CI/CD까지 해야할까 라고 생각했었지만, 언제나 최종사용자의 입장에서 생각해야 한다는 것을 뼈져리게 느끼게 되었다.

### 2-6. 글감

어떤 글이 사람들에게 더욱 도움이 될 지 감이 잡히기 시작했다. 인터넷의 빈공간을 채워가는 것을 앞으로의 포스팅 목표로 삼아보아야겠다.

## References

- [FXML에서 %를 사용할 수 없는 것은 의도된 사항](https://bugs.openjdk.org/browse/JDK-8091980)
- [2016년도에 보고된 full screen 버그리포트](https://bugs.openjdk.org/browse/JDK-8164210)
- [Launch Helper](https://mail.openjdk.org/pipermail/openjfx-dev/2018-June/021977.html)
- [Maven LaunchHelper 우회방안](https://nikhiladigaz.medium.com/deploying-non-modular-javafx-applications-using-maven-and-launch4j-fb95b8ab0739)
